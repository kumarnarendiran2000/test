name: e2e-test
needs: deps-check
runs-on: ubuntu-latest

steps:
  - uses: actions/checkout@v4

  - name: Setup pnpm
    uses: ./.github/actions/setup-pnpm

  - name: Setup Node.js
    uses: actions/setup-node@v4
    with:
      node-version: 20

  - name: Install dependencies
    run: pnpm install

  # Add a step here to create .env.development.local
  - name: Create .env.development.local
    run: |
      echo "EXPO_PUBLIC_LOCAL_RUN_API_BASE=http://localhost:3000" >> apps/dashboard/.env.development.local
      # If you have sensitive info, pull it from GitHub Secrets, e.g.:
      # echo "SECRET_TOKEN=${{ secrets.SECRET_TOKEN }}" >> apps/dashboard/.env.development.local

  - name: Run Backend and Mock-SLAL API servers
    run: |
      pnpm --filter back-end serve:mock &
      pnpm --filter mock-legacy-slal-api serve:local &

  - name: Run Frontend (Expo Web) # via Turbo
    run: |
      pnpm turbo run web --filter @ember/dashboard &
  
  - name: Wait for server
    run: sleep 250

  - name: Run Frontend (Expo Web) # or start again if needed
    run: |
      pnpm --filter @ember/dashboard web &
  
  - name: Wait for server
    run: sleep 250

  - name: Run E2E Test
    run: pnpm --filter e2e test:e2e:mock


If you want to modify the scripts in package.json to have two different test execution modes (headless and normal UI mode), hereâ€™s how you can do it.


---

1. Modify package.json Scripts

In package.json, add these two scripts:

"scripts": {
  "test:headless": "USE_HEADLESS=true npx wdio run wdio.conf.ts",
  "test:ui": "USE_HEADLESS=false npx wdio run wdio.conf.ts"
}

test:headless: Runs the test in headless mode (for CI).

test:ui: Runs the test in normal mode with UI (for local debugging).



---

2. Modify wdio.conf.ts

Now, update wdio.conf.ts to use the USE_HEADLESS flag:

export const config: WebdriverIO.Config = {
    maxInstances: 10,
    
    capabilities: process.env.USE_HEADLESS === 'true' ? [
        {
            browserName: 'MicrosoftEdge',
            'ms:edgeOptions': {
                args: ['--headless'],
            }
        },
        {
            browserName: 'chrome',
            'goog:chromeOptions': {
                args: ['--headless'],
            }
        },
        {
            browserName: 'firefox',
            'moz:firefoxOptions': {
                args: ['--headless'],
            }
        }
    ] : [
        {
            browserName: 'MicrosoftEdge'
        }
    ],

    // Other configurations...
};


---

3. Running the Tests

Now, you can execute tests in two different modes:

âœ… Run in Headless Mode (CI/CD):

npm run test:headless

âœ… Run in UI Mode (Local Debugging):

npm run test:ui


---

Alternative: Running Directly with Flags

If you donâ€™t want to modify package.json, you can directly pass the flag in the terminal:

USE_HEADLESS=true npx wdio run wdio.conf.ts  # Runs in headless mode
USE_HEADLESS=false npx wdio run wdio.conf.ts # Runs in normal UI mode


---

What Changes Were Made?

Added USE_HEADLESS as a flag to determine which capabilities to use.

Updated wdio.conf.ts to switch between headless and normal mode dynamically.

Created two npm scripts so you donâ€™t have to manually set the flag every time.



---

This setup ensures you can easily switch between CI/CD mode (headless) and local debugging mode (UI).

Would this approach work for your case? ðŸš€


If you want another way without using process.env, you can modify the wdio.conf.ts to dynamically pick capabilities based on a flag passed via the CLI arguments.


---

Solution: Use CLI Arguments (--headless)

Instead of using environment variables, WebdriverIO allows you to pass custom arguments via CLI, which can be accessed inside wdio.conf.ts using process.argv.

Modify wdio.conf.ts

Update the WebdriverIO config file to check for --headless in the command:

const isHeadless = process.argv.includes('--headless');

export const config: WebdriverIO.Config = {
  maxInstances: 10,

  capabilities: isHeadless ? [
    {
      browserName: 'MicrosoftEdge',
      'ms:edgeOptions': {
        args: ['--headless']
      }
    },
    {
      browserName: 'chrome',
      'goog:chromeOptions': {
        args: ['--headless']
      }
    },
    {
      browserName: 'firefox',
      'moz:firefoxOptions': {
        args: ['--headless']
      }
    }
  ] : [
    {
      browserName: 'MicrosoftEdge'
    }
  ],

  // Other configurations...
};


---

How to Use It

Now, instead of using environment variables, you can pass --headless as a flag when running WebdriverIO:

Run in Headless Mode

npx wdio run wdio.conf.ts --headless

Run in UI Mode (without headless)

npx wdio run wdio.conf.ts


---

Alternative: Use Scripts in package.json

Modify your package.json:

"scripts": {
  "test:headless": "npx wdio run wdio.conf.ts --headless",
  "test:ui": "npx wdio run wdio.conf.ts"
}

Run:

pnpm run test:headless  # Runs in headless mode
pnpm run test:ui        # Runs with UI


---

Why is This Better?

âœ… No need to set environment variables.
âœ… Works cross-platform without set or $env: issues.
âœ… Uses a simple CLI argument that integrates smoothly with WebdriverIO.
âœ… Can add more flags like --debug, --slow, etc., in the future.

Let me know if you need more tweaks! ðŸš€


Yes, it's a good practice to import only the required functions from fs instead of using import * as fs. This keeps the code cleaner and slightly improves performance by not loading unnecessary modules.

Optimized Import:

Instead of:

import * as fs from 'fs';

Use:

import { existsSync, mkdirSync } from 'fs';

Updated Function:

onPrepare: function (): void {
    console.log('Preparing for end-to-end test execution...');

    const directories: string[] = ['./logs', './screenshots/success', './screenshots/failure'];

    directories.forEach((dir: string) => {
        if (!existsSync(dir)) {
            mkdirSync(dir, { recursive: true });
        }
    });

    console.log('Setup completed: Logs and Screenshot directories are ready.');
}

Why This is Better?

âœ… Reduces memory footprint by importing only what's needed.
âœ… Improves readability and maintainability.
âœ… Keeps it more aligned with best practices in TypeScript.

This approach is recommended unless you need multiple functions from fs. ðŸš€


const safeTimestamp = new Date().toISOString().replace(/:/g, '-').replace('T', '_').replace('Z', '');
const screenShotPath = join(__dirname, `../screenshots/${status}/${testName}_${safeTimestamp}.png`);





