Yes! If you prefer a simpler approach without using class-based inheritance, you can implement the WebdriverIO Custom Reporter using a functional approach in TypeScript or JavaScript.


---

âœ… Alternative: Functional WebdriverIO Custom Reporter (No Class)

Instead of extending Reporter, you can directly define and export functions inside a module.

ğŸ“„ Create customLogger.ts inside tests/e2e/reporters/

import fs from 'fs';
import path from 'path';

const logFilePath = path.join(process.cwd(), 'tests/e2e/reports/wdio-e2e.log');

/**
 * Helper function to write logs to a file
 */
function writeLog(message: string) {
    const timeStamp = new Date().toISOString();
    const logMessage = `[${timeStamp}] ${message}\n`;
    fs.appendFileSync(logFilePath, logMessage, { encoding: 'utf8' });
}

export const CustomLogger = {
    onTestStart: (test: any) => {
        writeLog(`STARTING TEST: ${test.title}`);
    },
    onTestPass: (test: any) => {
        writeLog(`âœ… TEST PASSED: ${test.title}`);
    },
    onTestFail: (test: any) => {
        writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            writeLog(`ERROR: ${test.error.message}`);
        }
    },
    onTestEnd: (test: any) => {
        writeLog(`TEST ENDED: ${test.title}`);
    },
    onSuiteStart: (suite: any) => {
        writeLog(`ğŸ“Œ SUITE STARTED: ${suite.title}`);
    },
    onSuiteEnd: (suite: any) => {
        writeLog(`ğŸ“Œ SUITE ENDED: ${suite.title}`);
    },
    onRunnerEnd: () => {
        writeLog(`ğŸ¯ TEST RUN COMPLETED`);
    }
};


---

âœ… Step 2: Register in wdio.conf.ts

ğŸ“„ Modify wdio.conf.ts

import { CustomLogger } from './tests/e2e/reporters/customLogger';

export const config: WebdriverIO.Config = {
    reporters: [
        'spec',  // Keep the default Spec Reporter for console logs
        CustomLogger // Use functional logger
    ],
};


---

âœ… Why This is Better?

1. No need for a class â€“ uses a simple object with functions.


2. More readable â€“ just functions that WebdriverIO calls at different events.


3. No need to extend Reporter â€“ WebdriverIO directly calls our exported functions.




---

âœ… Works Exactly Like Before!

ğŸš€ Run your test suite, and logs will be saved inside:

tests/e2e/reports/wdio-e2e.log

âœ… Example log output:

[2025-02-18T14:35:01.987Z] ğŸ“Œ SUITE STARTED: User Dashboard Tests
[2025-02-18T14:35:05.312Z] STARTING TEST: Validates total value for TestUser
[2025-02-18T14:35:08.212Z] âœ… TEST PASSED: Validates total value for TestUser
[2025-02-18T14:35:12.198Z] STARTING TEST: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] âŒ TEST FAILED: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] ERROR: Expected Â£343.75 but found Â£0.00
[2025-02-18T14:35:18.001Z] ğŸ“Œ SUITE ENDED: User Dashboard Tests
[2025-02-18T14:35:20.453Z] ğŸ¯ TEST RUN COMPLETED


---

âœ… Bonus: Upload Logs in CI

If you want to upload the log file as an artifact in GitHub Actions, modify your .github/workflows/e2e-pipeline.yml:

- name: Upload WebdriverIO Logs
  uses: actions/upload-artifact@v4
  with:
    name: wdio-logs
    path: tests/e2e/reports/wdio-e2e.log
    retention-days: 7


---

Final Thoughts

ğŸ”¹ No need for class â€“ just a simple object with functions.
ğŸ”¹ Still fully compatible with WebdriverIO lifecycle hooks.
ğŸ”¹ Easier to maintain and avoids unnecessary complexity.

ğŸš€ You're all set! Run your tests and verify that logs are being generated.
Let me know if you need any modifications!





Great choice! Using a WebdriverIO Custom Reporter will help you structure your logs properly while keeping everything within WebdriverIO's ecosystem. Below is a step-by-step guide to implementing a custom reporter that logs test execution details to a file.


---

Step 1: Create a Custom Reporter File

WebdriverIO allows us to create a custom reporter by extending the Reporter class. Let's create a new reporter file:

ğŸ“ Directory Structure:

tests/
  â”œâ”€â”€ e2e/
  â”‚   â”œâ”€â”€ reports/
  â”‚   â”‚   â”œâ”€â”€ wdio-e2e.log
  â”‚   â”œâ”€â”€ reporters/
  â”‚   â”‚   â”œâ”€â”€ customLogger.ts

ğŸ“Œ Create customLogger.ts inside tests/e2e/reporters/


---

Step 2: Implement the Custom Reporter

ğŸ“„ customLogger.ts

import fs from 'fs';
import path from 'path';
import { Reporter } from '@wdio/reporter';

export default class CustomLogger extends Reporter {
    private logFilePath: string;

    constructor(options: any) {
        super(options);
        this.logFilePath = path.join(process.cwd(), 'tests/e2e/reports/wdio-e2e.log');
    }

    /**
     * Helper function to write logs to a file
     */
    private writeLog(message: string) {
        const timeStamp = new Date().toISOString();
        const logMessage = `[${timeStamp}] ${message}\n`;
        fs.appendFileSync(this.logFilePath, logMessage, { encoding: 'utf8' });
    }

    /**
     * Called when a test starts
     */
    public onTestStart(test: any) {
        this.writeLog(`STARTING TEST: ${test.title}`);
    }

    /**
     * Called when a test passes
     */
    public onTestPass(test: any) {
        this.writeLog(`âœ… TEST PASSED: ${test.title}`);
    }

    /**
     * Called when a test fails
     */
    public onTestFail(test: any) {
        this.writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            this.writeLog(`ERROR: ${test.error.message}`);
        }
    }

    /**
     * Called when a test completes (pass or fail)
     */
    public onTestEnd(test: any) {
        this.writeLog(`TEST ENDED: ${test.title}`);
    }

    /**
     * Called when the suite starts
     */
    public onSuiteStart(suite: any) {
        this.writeLog(`ğŸ“Œ SUITE STARTED: ${suite.title}`);
    }

    /**
     * Called when the suite ends
     */
    public onSuiteEnd(suite: any) {
        this.writeLog(`ğŸ“Œ SUITE ENDED: ${suite.title}`);
    }

    /**
     * Called when all tests finish execution
     */
    public onRunnerEnd() {
        this.writeLog(`ğŸ¯ TEST RUN COMPLETED`);
    }
}


---

Step 3: Register the Custom Reporter in wdio.conf.ts

Now that we have our custom reporter, we need to register it inside the WebdriverIO configuration file.

ğŸ“„ Modify wdio.conf.ts

import CustomLogger from './tests/e2e/reporters/customLogger';

export const config: WebdriverIO.Config = {
    reporters: [
        'spec',  // Keep the default Spec Reporter for console logs
        [CustomLogger, {}] // Add our custom logger
    ],
};


---

Step 4: Run Tests and View Logs

Once you run your test suite, WebdriverIO will automatically write test execution details to:

tests/e2e/reports/wdio-e2e.log

âœ… Example log output:

[2025-02-18T14:35:01.987Z] ğŸ“Œ SUITE STARTED: User Dashboard Tests
[2025-02-18T14:35:05.312Z] STARTING TEST: Validates total value for TestUser
[2025-02-18T14:35:08.212Z] âœ… TEST PASSED: Validates total value for TestUser
[2025-02-18T14:35:12.198Z] STARTING TEST: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] âŒ TEST FAILED: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] ERROR: Expected Â£343.75 but found Â£0.00
[2025-02-18T14:35:18.001Z] ğŸ“Œ SUITE ENDED: User Dashboard Tests
[2025-02-18T14:35:20.453Z] ğŸ¯ TEST RUN COMPLETED


---

Bonus: Upload Log File in CI Pipeline

If you want to upload the log file as an artifact in GitHub Actions, modify your .github/workflows/e2e-pipeline.yml:

- name: Upload WebdriverIO Logs
  uses: actions/upload-artifact@v4
  with:
    name: wdio-logs
    path: tests/e2e/reports/wdio-e2e.log
    retention-days: 7


---

Conclusion

ğŸš€ Now you have structured logs inside a WebdriverIO Custom Reporter!

This integrates directly with WebdriverIO's lifecycle.

It writes structured logs to a file.

You don't need Winston anymore.

It automatically logs test execution without manual function calls.


Next Steps:
âœ… Run the test suite and verify tests/e2e/reports/wdio-e2e.log is being generated.
âœ… Update your CI pipeline to upload logs as artifacts.

Let me know if you need any refinements! ğŸš€




----


Since you want to use WebdriverIOâ€™s custom reporter but without using classes, you'll need an alternative way to hook into WebdriverIOâ€™s lifecycle events while still registering a custom reporter.


---

ğŸš€ Implementing WebdriverIO Custom Reporter in a Functional Way

While WebdriverIOâ€™s Reporter requires class-based extension, you can wrap it in a function-based approach by creating a factory function.


---

1ï¸âƒ£ Create a Custom Reporter (customLogger.ts)

Since we canâ€™t directly extend the Reporter class in a function, we create a wrapper function that registers event handlers dynamically.

import Reporter from '@wdio/reporter';
import { appendFileSync } from 'fs';
import { join } from 'path';

// Log file path setup
const logFilePath = join(process.cwd(), 'logs/wdio-e2e.log');

// Helper function to write logs
function writeLog(message: string) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}\n`;
    appendFileSync(logFilePath, logMessage, { encoding: 'utf-8' });
}

// âœ… Function-based WebdriverIO Custom Reporter
export function createCustomReporter() {
    const reporter = new Reporter({});

    reporter.on('suite:start', (suite) => {
        writeLog(`ğŸŸ  SUITE STARTED: ${suite.title}`);
    });

    reporter.on('suite:end', (suite) => {
        writeLog(`ğŸŸ¢ SUITE ENDED: ${suite.title}`);
    });

    reporter.on('test:start', (test) => {
        writeLog(`ğŸ”µ STARTING TEST: ${test.title}`);
    });

    reporter.on('test:pass', (test) => {
        writeLog(`âœ… TEST PASSED: ${test.title}`);
    });

    reporter.on('test:fail', (test) => {
        writeLog(`âŒ TEST FAILED: ${test.title}`);
    });

    reporter.on('runner:end', (runner) => {
        const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
        writeLog(`ğŸš€ TEST RUN COMPLETED`);
        writeLog(`ğŸ”¹ FINAL STATUS: ${status}`);
    });

    return reporter;
}


---

2ï¸âƒ£ Register Custom Reporter in wdio.conf.ts

Since WebdriverIO expects reporters to be registered via configuration, we call our function inside wdio.conf.ts.

import { createCustomReporter } from './utils/customLogger';

export const config: WebdriverIO.Config = {
    // Other WebdriverIO settings...
    
    reporters: [
        [createCustomReporter()], // âœ… Registering function-based reporter
    ],
};


---

ğŸ“Œ How This Works

âœ”ï¸ createCustomReporter() returns a Reporter instance but is written without classes
âœ”ï¸ Lifecycle event handlers (on) listen dynamically
âœ”ï¸ Direct function-based logging is used (writeLog)
âœ”ï¸ No need to extend a class!


---

ğŸ”¹ Should You Use This?

âœ… If you want WebdriverIOâ€™s Custom Reporter but in a function-based structure
âœ… If you want lighter, modular logging without class inheritance
âœ… If you want flexibility in how logs are handled


---

ğŸš€ Summary


---

ğŸ’¡ Final Thought

Since WebdriverIO officially requires extending Reporter, if you absolutely need a custom reporter, the class-based method is recommended. But this function-based workaround lets you modularize logging while using WebdriverIOâ€™s reporting API.


---

Let me know if you need further improvements! ğŸš€


export default class CustomLogger extends Reporter {
    private logFilePath: string;

    constructor(options: any) {
        super(options);
        this.logFilePath = join(process.cwd(), 'logs/wdio-e2e.log');
    }

    private writeLog(message: string) {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${message}\n`;
        appendFileSync(this.logFilePath, logMessage, { encoding: 'utf-8' });
    }

    public onSuiteStart(suite: any) {
        this.writeLog(`ğŸŸ  SUITE STARTED: ${suite.title}`);
    }

    public onSuiteEnd(suite: any) {
        this.writeLog(`ğŸŸ¢ SUITE ENDED: ${suite.title}`);
    }

    public onTestStart(test: any) {
        this.writeLog(`ğŸ”µ STARTING TEST: ${test.title}`);
    }

    public onTestPass(test: any) {
        this.writeLog(`âœ… TEST PASSED: ${test.title}`);
    }

    public onTestFail(test: any) {
        this.writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            this.writeLog(`ğŸ”º ERROR: ${test.error.message}`);
        }
    }

    public onTestEnd(test: any) {
        this.writeLog(`ğŸ”¹ TEST ENDED: ${test.title}`);
    }

    public onRunnerEnd(runner: any) {
        const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
        const specs = runner.specs.join(', ');

        this.writeLog(`ğŸš€ TEST RUN COMPLETED`);
        this.writeLog(`ğŸ”¹ FINAL STATUS: ${status}`);
        this.writeLog(`ğŸ“„ Specs executed: ${specs}`);
    }
}



reporters: [
  'spec',
  ['path/to/CustomLogger', {
    outputDir: './logs',  // Set log directory
    filename: `wdio-e2e-${new Date().toISOString().split('T')[0]}.log` // Auto-generate daily log files
  }]
],

import Reporter from '@wdio/reporter';

export default class CustomLogger extends Reporter {
  constructor(options: any) {
    super(options);
  }

  public onSuiteStart(suite: any): void {
    this.write(`ğŸ“‚ SUITE STARTED: ${suite.title}\n`);
  }

  public onTestStart(test: any): void {
    this.write(`ğŸŸ¡ STARTING TEST: ${test.title}\n`);
  }

  public onTestPass(test: any): void {
    this.write(`âœ… TEST PASSED: ${test.title}\n`);
  }

  public onTestFail(test: any): void {
    this.write(`âŒ TEST FAILED: ${test.title}\n`);
    if (test.error) {
      this.write(`âš ï¸ ERROR: ${test.error.message}\n`);
    }
  }

  public onTestEnd(test: any): void {
    this.write(`ğŸ”µ TEST ENDED: ${test.title}\n`);
  }

  public onRunnerEnd(runner: any): void {
    const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
    this.write(`ğŸ TEST RUN COMPLETED\n`);
    this.write(`ğŸ“Œ FINAL STATUS: ${status}\n`);
    this.write(`ğŸ“œ Specs executed: ${runner.specs.join(', ')}\n`);
  }
}


Sure! Below is the complete WebdriverIO configuration and CustomLogger.ts implementation that:

âœ… Uses WebdriverIOâ€™s custom reporter
âœ… Logs into a separate folder per day (e.g., logs/2025-02-19/wdio-e2e.log)
âœ… Leverages this.write for structured logging
âœ… No deletion of logs, just structured storage


---

1. WebdriverIO Configuration (wdio.conf.ts)

This ensures the log folder is created dynamically for each test run.

import fs from 'fs';
import path from 'path';

export const config: WebdriverIO.Config = {
  framework: 'mocha',

  reporters: [
    ['spec'],
    ['customLogger', {}] // Register the custom logger
  ],

  onPrepare: () => {
    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    const logDir = path.join(process.cwd(), 'logs', date);

    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
      console.log(`Logs will be stored in: ${logDir}`);
    }
  },
};


---

2. Custom Reporter (customLogger.ts)

This will store logs in logs/YYYY-MM-DD/wdio-e2e.log and write logs via this.write.

import Reporter from '@wdio/reporter';
import { appendFileSync } from 'fs';
import { join } from 'path';

export default class CustomLogger extends Reporter {
  private logFilePath: string;

  constructor(options: any) {
    super(options);
    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    this.logFilePath = join(process.cwd(), 'logs', date, 'wdio-e2e.log');
  }

  private writeLog(message: string): void {
    appendFileSync(this.logFilePath, `${message}\n`, { encoding: 'utf-8' });
    this.write(message); // Uses WebdriverIOâ€™s built-in logging
  }

  public onSuiteStart(suite: any): void {
    this.writeLog(`ğŸŸ¢ SUITE STARTED: ${suite.title}`);
  }

  public onSuiteEnd(suite: any): void {
    this.writeLog(`ğŸ”´ SUITE ENDED: ${suite.title}`);
  }

  public onTestStart(test: any): void {
    this.writeLog(`ğŸš€ STARTING TEST: ${test.title}`);
  }

  public onTestPass(test: any): void {
    this.writeLog(`âœ… TEST PASSED: ${test.title}`);
  }

  public onTestFail(test: any): void {
    this.writeLog(`âŒ TEST FAILED: ${test.title}`);
    if (test.error) {
      this.writeLog(`âš ï¸ ERROR: ${test.error.message}`);
    }
  }

  public onTestEnd(test: any): void {
    this.writeLog(`ğŸ›‘ TEST ENDED: ${test.title}`);
  }

  public onRunnerEnd(runner: any): void {
    const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
    const specs = runner.specs.join(', ');

    this.writeLog(`ğŸ TEST RUN COMPLETED`);
    this.writeLog(`ğŸ“Œ FINAL STATUS: ${status}`);
    this.writeLog(`ğŸ“„ Specs executed: ${specs}`);
  }
}


---

Expected Folder & Log Structure

This will create logs per day like:

logs/
  â”œâ”€â”€ 2025-02-19/
  â”‚   â”œâ”€â”€ wdio-e2e.log
  â”œâ”€â”€ 2025-02-20/
  â”‚   â”œâ”€â”€ wdio-e2e.log

Example log file:

ğŸŸ¢ SUITE STARTED: Dashboard Tests
ğŸš€ STARTING TEST: Opens dashboard, authenticates, and accepts cookies
âœ… TEST PASSED: Opens dashboard, authenticates, and accepts cookies
ğŸ›‘ TEST ENDED: Opens dashboard, authenticates, and accepts cookies
...
ğŸ TEST RUN COMPLETED
ğŸ“Œ FINAL STATUS: PASSED
ğŸ“„ Specs executed: tests/e2e/dashboard.spec.ts


---

Final Thoughts

âœ… Uses WebdriverIO's this.write method

âœ… No manual deletion of logs

âœ… Each day has a separate log folder

âœ… Works seamlessly in CI/CD and local


Would this setup work for you?

