Yes! If you prefer a simpler approach without using class-based inheritance, you can implement the WebdriverIO Custom Reporter using a functional approach in TypeScript or JavaScript.


---

âœ… Alternative: Functional WebdriverIO Custom Reporter (No Class)

Instead of extending Reporter, you can directly define and export functions inside a module.

ðŸ“„ Create customLogger.ts inside tests/e2e/reporters/

import fs from 'fs';
import path from 'path';

const logFilePath = path.join(process.cwd(), 'tests/e2e/reports/wdio-e2e.log');

/**
 * Helper function to write logs to a file
 */
function writeLog(message: string) {
    const timeStamp = new Date().toISOString();
    const logMessage = `[${timeStamp}] ${message}\n`;
    fs.appendFileSync(logFilePath, logMessage, { encoding: 'utf8' });
}

export const CustomLogger = {
    onTestStart: (test: any) => {
        writeLog(`STARTING TEST: ${test.title}`);
    },
    onTestPass: (test: any) => {
        writeLog(`âœ… TEST PASSED: ${test.title}`);
    },
    onTestFail: (test: any) => {
        writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            writeLog(`ERROR: ${test.error.message}`);
        }
    },
    onTestEnd: (test: any) => {
        writeLog(`TEST ENDED: ${test.title}`);
    },
    onSuiteStart: (suite: any) => {
        writeLog(`ðŸ“Œ SUITE STARTED: ${suite.title}`);
    },
    onSuiteEnd: (suite: any) => {
        writeLog(`ðŸ“Œ SUITE ENDED: ${suite.title}`);
    },
    onRunnerEnd: () => {
        writeLog(`ðŸŽ¯ TEST RUN COMPLETED`);
    }
};


---

âœ… Step 2: Register in wdio.conf.ts

ðŸ“„ Modify wdio.conf.ts

import { CustomLogger } from './tests/e2e/reporters/customLogger';

export const config: WebdriverIO.Config = {
    reporters: [
        'spec',  // Keep the default Spec Reporter for console logs
        CustomLogger // Use functional logger
    ],
};


---

âœ… Why This is Better?

1. No need for a class â€“ uses a simple object with functions.


2. More readable â€“ just functions that WebdriverIO calls at different events.


3. No need to extend Reporter â€“ WebdriverIO directly calls our exported functions.




---

âœ… Works Exactly Like Before!

ðŸš€ Run your test suite, and logs will be saved inside:

tests/e2e/reports/wdio-e2e.log

âœ… Example log output:

[2025-02-18T14:35:01.987Z] ðŸ“Œ SUITE STARTED: User Dashboard Tests
[2025-02-18T14:35:05.312Z] STARTING TEST: Validates total value for TestUser
[2025-02-18T14:35:08.212Z] âœ… TEST PASSED: Validates total value for TestUser
[2025-02-18T14:35:12.198Z] STARTING TEST: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] âŒ TEST FAILED: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] ERROR: Expected Â£343.75 but found Â£0.00
[2025-02-18T14:35:18.001Z] ðŸ“Œ SUITE ENDED: User Dashboard Tests
[2025-02-18T14:35:20.453Z] ðŸŽ¯ TEST RUN COMPLETED


---

âœ… Bonus: Upload Logs in CI

If you want to upload the log file as an artifact in GitHub Actions, modify your .github/workflows/e2e-pipeline.yml:

- name: Upload WebdriverIO Logs
  uses: actions/upload-artifact@v4
  with:
    name: wdio-logs
    path: tests/e2e/reports/wdio-e2e.log
    retention-days: 7


---

Final Thoughts

ðŸ”¹ No need for class â€“ just a simple object with functions.
ðŸ”¹ Still fully compatible with WebdriverIO lifecycle hooks.
ðŸ”¹ Easier to maintain and avoids unnecessary complexity.

ðŸš€ You're all set! Run your tests and verify that logs are being generated.
Let me know if you need any modifications!





Great choice! Using a WebdriverIO Custom Reporter will help you structure your logs properly while keeping everything within WebdriverIO's ecosystem. Below is a step-by-step guide to implementing a custom reporter that logs test execution details to a file.


---

Step 1: Create a Custom Reporter File

WebdriverIO allows us to create a custom reporter by extending the Reporter class. Let's create a new reporter file:

ðŸ“ Directory Structure:

tests/
  â”œâ”€â”€ e2e/
  â”‚   â”œâ”€â”€ reports/
  â”‚   â”‚   â”œâ”€â”€ wdio-e2e.log
  â”‚   â”œâ”€â”€ reporters/
  â”‚   â”‚   â”œâ”€â”€ customLogger.ts

ðŸ“Œ Create customLogger.ts inside tests/e2e/reporters/


---

Step 2: Implement the Custom Reporter

ðŸ“„ customLogger.ts

import fs from 'fs';
import path from 'path';
import { Reporter } from '@wdio/reporter';

export default class CustomLogger extends Reporter {
    private logFilePath: string;

    constructor(options: any) {
        super(options);
        this.logFilePath = path.join(process.cwd(), 'tests/e2e/reports/wdio-e2e.log');
    }

    /**
     * Helper function to write logs to a file
     */
    private writeLog(message: string) {
        const timeStamp = new Date().toISOString();
        const logMessage = `[${timeStamp}] ${message}\n`;
        fs.appendFileSync(this.logFilePath, logMessage, { encoding: 'utf8' });
    }

    /**
     * Called when a test starts
     */
    public onTestStart(test: any) {
        this.writeLog(`STARTING TEST: ${test.title}`);
    }

    /**
     * Called when a test passes
     */
    public onTestPass(test: any) {
        this.writeLog(`âœ… TEST PASSED: ${test.title}`);
    }

    /**
     * Called when a test fails
     */
    public onTestFail(test: any) {
        this.writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            this.writeLog(`ERROR: ${test.error.message}`);
        }
    }

    /**
     * Called when a test completes (pass or fail)
     */
    public onTestEnd(test: any) {
        this.writeLog(`TEST ENDED: ${test.title}`);
    }

    /**
     * Called when the suite starts
     */
    public onSuiteStart(suite: any) {
        this.writeLog(`ðŸ“Œ SUITE STARTED: ${suite.title}`);
    }

    /**
     * Called when the suite ends
     */
    public onSuiteEnd(suite: any) {
        this.writeLog(`ðŸ“Œ SUITE ENDED: ${suite.title}`);
    }

    /**
     * Called when all tests finish execution
     */
    public onRunnerEnd() {
        this.writeLog(`ðŸŽ¯ TEST RUN COMPLETED`);
    }
}


---

Step 3: Register the Custom Reporter in wdio.conf.ts

Now that we have our custom reporter, we need to register it inside the WebdriverIO configuration file.

ðŸ“„ Modify wdio.conf.ts

import CustomLogger from './tests/e2e/reporters/customLogger';

export const config: WebdriverIO.Config = {
    reporters: [
        'spec',  // Keep the default Spec Reporter for console logs
        [CustomLogger, {}] // Add our custom logger
    ],
};


---

Step 4: Run Tests and View Logs

Once you run your test suite, WebdriverIO will automatically write test execution details to:

tests/e2e/reports/wdio-e2e.log

âœ… Example log output:

[2025-02-18T14:35:01.987Z] ðŸ“Œ SUITE STARTED: User Dashboard Tests
[2025-02-18T14:35:05.312Z] STARTING TEST: Validates total value for TestUser
[2025-02-18T14:35:08.212Z] âœ… TEST PASSED: Validates total value for TestUser
[2025-02-18T14:35:12.198Z] STARTING TEST: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] âŒ TEST FAILED: Validates latest payment value for TestUser
[2025-02-18T14:35:15.789Z] ERROR: Expected Â£343.75 but found Â£0.00
[2025-02-18T14:35:18.001Z] ðŸ“Œ SUITE ENDED: User Dashboard Tests
[2025-02-18T14:35:20.453Z] ðŸŽ¯ TEST RUN COMPLETED


---

Bonus: Upload Log File in CI Pipeline

If you want to upload the log file as an artifact in GitHub Actions, modify your .github/workflows/e2e-pipeline.yml:

- name: Upload WebdriverIO Logs
  uses: actions/upload-artifact@v4
  with:
    name: wdio-logs
    path: tests/e2e/reports/wdio-e2e.log
    retention-days: 7


---

Conclusion

ðŸš€ Now you have structured logs inside a WebdriverIO Custom Reporter!

This integrates directly with WebdriverIO's lifecycle.

It writes structured logs to a file.

You don't need Winston anymore.

It automatically logs test execution without manual function calls.


Next Steps:
âœ… Run the test suite and verify tests/e2e/reports/wdio-e2e.log is being generated.
âœ… Update your CI pipeline to upload logs as artifacts.

Let me know if you need any refinements! ðŸš€




----


Since you want to use WebdriverIOâ€™s custom reporter but without using classes, you'll need an alternative way to hook into WebdriverIOâ€™s lifecycle events while still registering a custom reporter.


---

ðŸš€ Implementing WebdriverIO Custom Reporter in a Functional Way

While WebdriverIOâ€™s Reporter requires class-based extension, you can wrap it in a function-based approach by creating a factory function.


---

1ï¸âƒ£ Create a Custom Reporter (customLogger.ts)

Since we canâ€™t directly extend the Reporter class in a function, we create a wrapper function that registers event handlers dynamically.

import Reporter from '@wdio/reporter';
import { appendFileSync } from 'fs';
import { join } from 'path';

// Log file path setup
const logFilePath = join(process.cwd(), 'logs/wdio-e2e.log');

// Helper function to write logs
function writeLog(message: string) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}\n`;
    appendFileSync(logFilePath, logMessage, { encoding: 'utf-8' });
}

// âœ… Function-based WebdriverIO Custom Reporter
export function createCustomReporter() {
    const reporter = new Reporter({});

    reporter.on('suite:start', (suite) => {
        writeLog(`ðŸŸ  SUITE STARTED: ${suite.title}`);
    });

    reporter.on('suite:end', (suite) => {
        writeLog(`ðŸŸ¢ SUITE ENDED: ${suite.title}`);
    });

    reporter.on('test:start', (test) => {
        writeLog(`ðŸ”µ STARTING TEST: ${test.title}`);
    });

    reporter.on('test:pass', (test) => {
        writeLog(`âœ… TEST PASSED: ${test.title}`);
    });

    reporter.on('test:fail', (test) => {
        writeLog(`âŒ TEST FAILED: ${test.title}`);
    });

    reporter.on('runner:end', (runner) => {
        const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
        writeLog(`ðŸš€ TEST RUN COMPLETED`);
        writeLog(`ðŸ”¹ FINAL STATUS: ${status}`);
    });

    return reporter;
}


---

2ï¸âƒ£ Register Custom Reporter in wdio.conf.ts

Since WebdriverIO expects reporters to be registered via configuration, we call our function inside wdio.conf.ts.

import { createCustomReporter } from './utils/customLogger';

export const config: WebdriverIO.Config = {
    // Other WebdriverIO settings...
    
    reporters: [
        [createCustomReporter()], // âœ… Registering function-based reporter
    ],
};


---

ðŸ“Œ How This Works

âœ”ï¸ createCustomReporter() returns a Reporter instance but is written without classes
âœ”ï¸ Lifecycle event handlers (on) listen dynamically
âœ”ï¸ Direct function-based logging is used (writeLog)
âœ”ï¸ No need to extend a class!


---

ðŸ”¹ Should You Use This?

âœ… If you want WebdriverIOâ€™s Custom Reporter but in a function-based structure
âœ… If you want lighter, modular logging without class inheritance
âœ… If you want flexibility in how logs are handled


---

ðŸš€ Summary


---

ðŸ’¡ Final Thought

Since WebdriverIO officially requires extending Reporter, if you absolutely need a custom reporter, the class-based method is recommended. But this function-based workaround lets you modularize logging while using WebdriverIOâ€™s reporting API.


---

Let me know if you need further improvements! ðŸš€


export default class CustomLogger extends Reporter {
    private logFilePath: string;

    constructor(options: any) {
        super(options);
        this.logFilePath = join(process.cwd(), 'logs/wdio-e2e.log');
    }

    private writeLog(message: string) {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${message}\n`;
        appendFileSync(this.logFilePath, logMessage, { encoding: 'utf-8' });
    }

    public onSuiteStart(suite: any) {
        this.writeLog(`ðŸŸ  SUITE STARTED: ${suite.title}`);
    }

    public onSuiteEnd(suite: any) {
        this.writeLog(`ðŸŸ¢ SUITE ENDED: ${suite.title}`);
    }

    public onTestStart(test: any) {
        this.writeLog(`ðŸ”µ STARTING TEST: ${test.title}`);
    }

    public onTestPass(test: any) {
        this.writeLog(`âœ… TEST PASSED: ${test.title}`);
    }

    public onTestFail(test: any) {
        this.writeLog(`âŒ TEST FAILED: ${test.title}`);
        if (test.error) {
            this.writeLog(`ðŸ”º ERROR: ${test.error.message}`);
        }
    }

    public onTestEnd(test: any) {
        this.writeLog(`ðŸ”¹ TEST ENDED: ${test.title}`);
    }

    public onRunnerEnd(runner: any) {
        const status = runner.failures > 0 ? 'FAILED' : 'PASSED';
        const specs = runner.specs.join(', ');

        this.writeLog(`ðŸš€ TEST RUN COMPLETED`);
        this.writeLog(`ðŸ”¹ FINAL STATUS: ${status}`);
        this.writeLog(`ðŸ“„ Specs executed: ${specs}`);
    }
}



