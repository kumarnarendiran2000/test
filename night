export async function waitForPageLoadWithRefresh(timeout = 50000, refreshTimeout = 10000) {
    try {
        // Wait for the page to fully load within the given timeout
        await browser.waitUntil(
            async () => (await browser.execute(() => document.readyState)) === 'complete',
            { timeout, interval: 500 }
        );
    } catch (error) {
        console.warn(`⚠️ Page did not load in ${timeout / 1000} seconds. Refreshing...`);
        
        // Refresh the page
        await browser.refresh();

        // Wait again after refresh
        await browser.waitUntil(
            async () => (await browser.execute(() => document.readyState)) === 'complete',
            { timeout: refreshTimeout, interval: 500 }
        );
    }
}

async openDashboard(url: string) {
    const handles = await browser.getWindowHandles();

    if (handles.length === 1) {
        // If only one tab exists, navigate to the URL instead of opening a new one
        console.warn("Only one tab exists, navigating instead of opening a new tab...");
        await browser.url(url);
    } else {
        // If multiple tabs exist, check if the URL is already open
        const currentUrl = await browser.getUrl();
        if (currentUrl !== url) {
            console.warn("Opening a new tab since the URL is different...");
            await browser.newWindow(url, { type: 'tab' });
        } else {
            console.warn("The correct URL is already open, no new tab needed.");
        }
    }

    // Ensure the page is fully loaded
    await waitForPageLoadWithRefresh();
}

class EmberDashboardPage {
    hasOpenedNewTab = false; // Track whether a new tab was opened

    async openDashboard(url: string) {
        const handles = await browser.getWindowHandles();

        if (!this.hasOpenedNewTab) {
            // First time: Load in the same tab
            console.warn("First loop: Navigating in the same tab...");
            await browser.url(url);
            this.hasOpenedNewTab = true; // Mark that the first round is done
        } else {
            // Second time and beyond: Open in a new tab only once
            console.warn("Second loop onward: Opening a new tab...");
            await browser.newWindow(url, { type: 'tab' });
        }

        // Ensure the page is fully loaded
        await waitForPageLoadWithRefresh();
    }
}

class EmberDashboardPage {
    async openDashboard(url: string): Promise<void> {
        const handles = await browser.getWindowHandles();

        if (handles.length === 1) {
            console.warn("Only one tab exists (probably WDIO blank page). Closing it...");
            await browser.closeWindow(); // Close the default blank tab
            const newHandles = await browser.getWindowHandles();
            await browser.switchToWindow(newHandles[0]); // Ensure we're on an active tab
        }

        console.warn("Opening a new tab...");
        await browser.newWindow(url, { type: 'tab' });

        // Ensure the page is fully loaded
        await waitForPageLoadWithRefresh();
    }
}

class EmberDashboardPage {
    private hasClosedBlankTab: boolean = false; // Track if we already closed the blank tab

    async openDashboard(url: string): Promise<void> {
        const handles = await browser.getWindowHandles();

        if (handles.length === 1 && !this.hasClosedBlankTab) {
            console.warn("First iteration: Closing WDIO's default blank tab...");
            await browser.closeWindow();
            const newHandles = await browser.getWindowHandles();
            await browser.switchToWindow(newHandles[0]); // Ensure we're on an active tab
            this.hasClosedBlankTab = true; // Prevent closing the real tab later
        }

        console.warn("Opening a new tab...");
        await browser.newWindow(url, { type: 'tab' });

        // Ensure the page is fully loaded
        await waitForPageLoadWithRefresh();
    }
}

async openDashboard(url: string): Promise<void> {
    const hasOpenedNewTab = await browser.execute(() => sessionStorage.getItem('hasOpenedNewTab'));

    if (!hasOpenedNewTab) {
        console.warn("First loop: Navigating in the same tab...");
        await browser.url(url);
        await browser.execute(() => sessionStorage.setItem('hasOpenedNewTab', 'true'));
    } else {
        console.warn("Second loop onward: Opening a new tab...");
        await browser.newWindow(url, { type: 'tab' });
    }

    await waitForPageLoadWithRefresh();
}

class EmberDashboardPage {
    private static hasOpenedNewTab: boolean = false; // Static so it persists across function calls

    async openDashboard(url: string): Promise<void> {
        if (!EmberDashboardPage.hasOpenedNewTab) {
            console.warn("First loop: Navigating in the same tab...");
            await browser.url(url);
            EmberDashboardPage.hasOpenedNewTab = true; // Set true so next call opens a new tab
        } else {
            console.warn("Second loop onward: Opening a new tab...");
            await browser.newWindow(url, { type: 'tab' });
        }

        // Ensure the page is fully loaded
        await waitForPageLoadWithRefresh();
    }
}

async openDashboard(url: string): Promise<void> {
    const hasOpenedNewTab = await browser.execute(() => sessionStorage.getItem('hasOpenedNewTab'));

    if (!hasOpenedNewTab) {
        console.warn("First loop: Navigating in the same tab...");
        await browser.url(url);
        await browser.execute(() => sessionStorage.setItem('hasOpenedNewTab', 'true'));
    } else {
        console.warn("Second loop onward: Opening a new tab...");
        await browser.newWindow(url, { type: 'tab' });
    }

    await waitForPageLoadWithRefresh();
}

class EmberDashboardPage {
    // No need for a static class variable, we rely on sessionStorage

    async openDashboard(url: string): Promise<void> {
        // Retrieve the value from sessionStorage
        const hasOpenedNewTab = await browser.execute(() => sessionStorage.getItem('hasOpenedNewTab'));

        if (!hasOpenedNewTab) {
            console.warn("First loop: Navigating in the same tab...");
            await browser.url(url);

            // Store flag in sessionStorage
            await browser.execute(() => sessionStorage.setItem('hasOpenedNewTab', 'true'));
        } else {
            console.warn("Second loop onward: Opening a new tab...");
            await browser.newWindow(url, { type: 'tab' });
        }

        await waitForPageLoadWithRefresh();
    }
}


To create selectors for this logout confirmation message in your Page Object Model (POM), you can define them in your selectors file and then access them in your page class.

Selectors (e.g., logoutSelectors.ts)

export const logoutSelectors = {
  logoutMessage: '//pre[contains(text(), "Logout successful")]', // XPath for the logout confirmation message
  csrfToken: '//pre[contains(text(), "csrfToken")]', // XPath to verify CSRF token presence
};

Page Object (e.g., LogoutPage.ts)

import { logoutSelectors } from '../selectors/logoutSelectors';

class LogoutPage {
  async verifyLogoutMessage(): Promise<void> {
    const message = await $(logoutSelectors.logoutMessage);
    await message.waitForDisplayed({ timeout: 5000 });
    expect(await message.getText()).toContain('Logout successful');
  }

  async verifyCSRFToken(): Promise<void> {
    const csrfToken = await $(logoutSelectors.csrfToken);
    await csrfToken.waitForDisplayed({ timeout: 5000 });
    expect(await csrfToken.getText()).not.toBeNull();
  }
}

export default new LogoutPage();

Usage in Spec File (e.g., logout.e2e.ts)

import LogoutPage from '../pages/LogoutPage';

describe('Logout Test', () => {
  it('should display logout confirmation message', async () => {
    await LogoutPage.verifyLogoutMessage();
    await LogoutPage.verifyCSRFToken();
  });
});

This ensures that after logout, your test checks for:

1. The logout success message (Logout successful).


2. The presence of the CSRF token (to validate API response integrity).



Let me know if you need refinements!

